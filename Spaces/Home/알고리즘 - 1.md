# 자료구조 개념

> 자료가 들어가는 그릇을 효율적으로 관리하는 방법
> 목적지까지 최적의 이동 경로를 찾는 방법

# 자료구조 종류

> 단순 자료구조: 정수 / 실수 / 문자 / 문자열 등
> 선형 자료구조: 리스트 / 스택 / 큐 / 데크(2중 큐)
> 비선형 자료구조: 트리 / 그래프
> 파일 자료구조: 순차 파일 / 색인 파일 / 직접 파일

[[자료구조 - 1]] 고정소수점 / 부동소수점
# 알고리즘 개념

> 문제 해결 과정을 묘사하는 것 - 문제 해결 절차를 체계적으로 기술한 것
> 문제의 요구 조건(입력과 출력 명시, 입력으로부터 출력을 만드는 기술)

> 입출력의 예
> 100명의 학생의 시험점수의 최대값을 찾으라
> 100명의 시험 점수
> 100개중 최대 값

> 특정한 문제를 위한 알고리즘의 습득
> 체계적으로 생각하는 훈련
> 지적 추상화의 레벨 상승
> 	Intellectual abstraction
> 	연구나 개발에 있어 정신적 여유를 유지하기 위해 매우 중요한 요소

> 알고리즘은 생각하는 방법을 훈련하는 것
> 	문제 자체를 해결하는 알고리즘 습득
> 	그 과정에 깃든 생각하는 방법을 배움
> 	미래에 다른 문제를 해결하는 생각의 빌딩블록을 제공

>> top-down / bottom-up .. WBS ..

> 알고리즘은 자료구조의 확장
> 	프로그래밍, 자료구조
> 	자료구조는 건축 자재나 모듈같은 것

> 어떤 문제를 해결해가는 논리적인 과정

> 자료구조: 컴퓨터 분야에서 효율적으로 접근하고 수정할 수 있도록 자료를 구성 관리 저장하는 것

> 알고리즘: 컴퓨터 분야나 수학 등 관련 분야에서 어떤 문제를 해결하기 위해 정해진 일련의 단계적인 절차, 방법

### 알고리즘 정의
> 문제를 해결하거나 함수를 계산하기 위해 좇아야 할 모호함이 없는 간단한 명령들로 구성된 일련의 순서적 단계
> 특정한 작업을 수행하기 위한 유한 명령어들로 구성되며 컴퓨터의 수행에 적합한 문제 해결을 위한 방법

### 알고리즘 목표
> 단순히 원하는 결과뿐 아니라 처리 시간이나 기억장소 사용 측면에서 효율적인 알고리즘 개발
> 효율성: 효율적인 해결 방법들을 발견하여 활용
> 추상화: 복잡한 문제도 효율적인 알고리즘으로 해결할 수 있는 단순한 문제들로 분류
> 재사용성: 단순한 문제를 효율적 해결 가능한 알고리즘은 다른 많은 문제 해결에도 활용

### 알고리즘의 역할
> 모듈성: 소프트웨어 설계는 모듈성을 얻기 위해 black box 개발에 초점
> 사용자는 모듈에 대해 개발자가 규정한 공개 인터페이스를 통해서만 접근 가능
> 모듈 상세 구현에 관심이 불필요하며 모듈 내부 임의 변경도 이론상 불가

> 단순성: 문제 해결에서 똑똑한 결과는 가장 단순한 방법

> 가독성: 의미 있는 주석
> 적절한 이름을 가진 식별자를 사용하는 것
> 그 자체로 설명되어지는 코드를 만드는 것
> 헤더 파일을 이용해 자료구조와 알고리즘에 대한 공개 인터페이스 정의하고 공개하여 가독성 높임

> 일관성: 규칙과 규칙을 바탕으로 만들어진 것을 이해하면 이 후 그것들을 보기만 해도 이해 가능
> 일관성은 가독성과 단순성 증진
> 형식에 대해 사용되는 대표 규칙
> 개인함수로써 정적 함수를 사용하는 방법


### 알고리즘의 조건
> 입출력 / 명확성 / 유한성 / 실용성 / 효율성
> 궁극적으로 컴퓨터를 통해서 구현되어야 함

> 알고리즘 생성 절차: 설계  -> 표현 검증 -> 효율성 -> 분석

# 알고리즘 표현법

### 일반 언어 표현
> 일반 자연어를 사용해서 설명하듯이 알고리즘을 표현
> 일반 사람이 이해하기 쉽게 표현할 수 있으나, 최정적으로 코드로 변경에 한계
> 어떤 알고리즘을 사용할지 아이디어가 떠오르지 않는 시점에서 생각 범위를 넓히는 단계에 사용

### 순서도 표현
> 여러 종류의 상자와 상자를 이어주는 화살표를 이용하여 명령 순서 표현
> 간단한 알고리즘은 쉽게 표현할 수 있지만 복잡한 알고리즘은 표현하기 어려움

### 의사코드 표현
> 프로그래밍 언어보다는 좀 더 인간의 언어에 가까운 형태
> 프로그램 코드와 일반어의 중간 형태
> 프로그램 코드를 직접 코딩하는 것보다 알고리즘을 좀 더 명확하게 정립하는데 도움이 되고 코드에 설명을 달지 않아도 이해에 무리 없음

### 프로그램 코드로 표현
> 실제로 사용하는 프로그래밍 언어의 코드로 바로 작성 가능

### 혼합 형태
> 간단한 알고리즘은 직접 코드로 작성
> 복잡한 알고리즘은 일반 언어, 의사코드, 순서도, 그림 등을 종합적으로 활용해서 표현

# 알고리즘 성능

### 성능 측정
> 시간복잡도(Time Complex): 소요 시간을 기준으로 알고리즘 성능을 분석

### 성능 표기
> 빅오 표기법
[[자료구조 - 1]]


---

# 알고리즘 표현 방법

### 알고리즘 표현 방법 및 종류
> 자연어
> 일상적으로 사용하는 말과 글로 표현
> 말과 글이 지닌 모호성 때문에 알고리즘의 명확성을 지키지 못할 가능성

> 순서도
> 순서도나 NS차트와 같은 그래픽적 표현 방법
> 표현방법이 복잡하고 대규모의 알고리즘을 표현하기 힘든 문제, 읽기와 수정하기 곤란

> 가상코드(Pseudo Code) - 수학??
> 자연어 기술 방법을 보다 간단화한 것으로 알고리즘을 프로그래밍 언어와 유사한 형태로 풀어 쓴 것

> 프로그래밍 언어


# 알고리즘 분석 기준

### 알고리즘 설계와 분석의 기초
> 전혀 새로운 아이디어를 갑자기 착상하는 일이 자주 있다.
> 하지만 그것을 착상하기까지 오랫동안 문제를 생각한다.
> 오랫동안 생각한 끝에 갑자기 답을 착상하는 것이다.

### 알고리즘의 분석 기준
> 알고리즘의 수행 시간과 명령어의 실행 빈도수, 기억 공간 등이 사용
> 정확성: 기대되는 출력에 대한 정확한 이해, 일반적으로 귀납법을 이용
> 작업량: 문제를 해결하기 위한 가장 적은 작업량을 갖는 알고리즘, 수행시간, 연산개수 등
> 기억 장소 사용량: 프로그램이 실행될 떄 기억 장치의 사용량
> 단순성: 단순한 디자인의 알고리즘, 정확성 증명 용이, 디버깅 또는 수정 용이
> 최적성: 최적이라는 의미는 가장 잘 알려진이 아니라 가장 좋은의 의미, 가장 최적의 알고리즘 말함

### 알고리즘 분석의 필요성
> 같은 문제를 해결하는 여러 알고리즘 존재
> 주어진 상황에 맞는 최적의 알고리즘 선택 위함
> 문제 해결에 속도에 비중을 둘 것인지, 단순성에 비중을 둘 것인지 등에 따라 선택이 달라짐

### 알고리즘의 분석 단계
> 1단계: 알고리즘에 입력될 데이터의 특성을 결정
> 메모리 요구사항이나 필요 조건에 대하여 평균적인 수행시간을 얻을 수 있는 입력데이터 정함

> 2단계: 수행시간에 직접적으로 영향을 미치는 연산들을 분리하여 기본적인 연산을 결정

> 3단계: 기본적인 연산들의 각 연산횟수에 대하여 평균의 경우와 최악의 경우에 대한 수학적 분석을 수행

# 알고리즘 복잡도

### 점근적 분석
> 입력의 크기가 충분히 큰 경우에 대한 분석
> 빅 오비크론, 빅 오메가, 빅 세타 등 많이 사용

### 점근적인 복잡도 평가 - 시간복잡도 평가
> 매개변수 n: 알고리즘에서 문제의 크기를 나타냄
> 점근적인 복잡도 평가: 알고리즘의 복잡도를 평가할 때 주요항 이외의 항 무시, 점근적인 복잡도 평가라고 함
> 공간복잡도: 프로그램을 실행시켜 완료하는데 소요되는 총 저장공간
```java
public float sum(Float[] list, int n) {  
    Float sum = (float) 0;  
    for(int i = 0; i<n; i++) {  
        sum+= list[i];  
    }  
    return sum;  
}
```

> 시간복잡도: 컴파일 시간 + 실행 시간

### 시간 복잡도 분석 종류
> Worst-case
> Average-case
> Best-case


# 점근적 표기법

### O(g(n)) 
> Tight or loose upper bound
### Ω(g(n))
> Tight or loose lower bound
### ⍬(g(n))
> Tight bound
### o(g(n))
> Loose upper bound
### ⍵(g(n))
Loose lower bound

### 크기 n인 배열에서 원소 찾기
> Sequential search : 배열이 아무렇게나 저장되어 있을 때 worse = average = ⍬(n) 
> Binary search: 배열이 정렬되어 있을 때 worse = average = ⍬(log n)

