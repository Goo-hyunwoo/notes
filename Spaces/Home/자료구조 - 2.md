# 순차구조

### 순차 자료구조(sequential structure)
> 구현할 자료들을 논리적인 순서대로 메모리에 연속하여 저장하여 구현하는 방식
> 논리적인 순서와 물리적인 순서가 항상 일치 - 삽입, 삭제 발생 시에도 반드시 일치
> 배열을 이용하여 많이 구현

### 연결 자료구조
> 메모리에 저장된 물리적 위치나 순서와 상관 없이 링크에 의해 논리적인 순서를 표현
> 삽입, 삭제 연산을 하여 논리적인 순서가 변경되어도, 링크 정보만 변경됨
> 포인터를 이용한 구현


# 선형 리스트(linear list)

> 자료를 구조화하는 가장 기본적인 방법으로서 자료를 나열한 목록 또는 자료들 간에 순서를 갖는 리스트
> 리스트의 자료는 노드(node) 또는 요소(element)

> 자료들이 순서대로 연속적으로 메모리에 저장됨
> 	원소들의 논리적 순서와 같은 순서로 메모리에 저장(순차구조)
> 접근 속도가 빠르고, 알고리즘이 쉬움

> 표기 -> L = (e1,e2,e3...) , L = ()
> 동일한 자료형의 원소

> 선형 리스트의 ADT (추상 자료형)
> 데이터 (유한집합), 연산자 및 연산 내용(create, isEmpty, length, retrieve, replace, delete, insert)

> 선형 리스트의 저장과 원소 위치 계산
> 리스트의 시작 위치:a, 원소의 크기: l. i번째 원소의 위치: a + (i-1) * l

> 원소의 삽입: 중간에 원소가 삽입되면 그 이후의 원소들은 한 자리씩 자리를 뒤로 이동
> 시나리오: 맨 뒤에 공간 추가 -> 삽입 위치부터 뒤의 원소들을 한 칸씩 뒤로 이동 -> 빈 자리에 삽입 값 입력
> 이동횟수: n개 + k번째에 추가 1 -> n - k + 1

> 원소의 삭제: 선형 리스트 중간에 원소가 삭제되면 그 이후의 원소들은 한 자리씩 앞으로 이동
> 시나리오: 삭제 -> 삭제 위치 뒤부터 한 칸씩 앞으로 자리 이동
> 이동횟수: n - k



# 배열

> 동일한 자료형(기본 자료형, 구조체, 포인터 등)들이 <색인, 원소>의 순서쌍으로 집단화한 선형 자료구조(순차적 저장, 유한 집합)

> 하나의 변수에 여러 값을 저장하는데 쓰이는 정적 리스트 구조
> 	원소의 개수가 정해져서 항상 마지막 원소가 존재
> 색인(index)을 이용하여 자료형이 같은 데이터를 관리 및 집합 내에서 상대적인 위치의 식별(접근) 가능
> 시스템 데이터 형으로 주로 연속적인 기억공간 할당으로 구현되며 기억공간 할당 방식과는 독립적
> 정보의 은닉 => 색인을 갖고 어떻게 원소 값에 접근하느냐는 사용자는 몰라도 됨

> 배열의 ADT
> 데이터: <index, element> 쌍들의 집합
> 연산자 및 연산내용: create, retrieve, store

> 연산: 순회, 삽입 / 삭제, 정렬 및 탐색
> 각 원소들을 이동하기 때문에 삽입 / 삭제가 빈번한 경우 효과적인 자료 구조는 아님 => 연결 리스트

> 배열의 크기: 배열 요소를 참조하기 위해 행 / 열에 대한 두 개 이상의 색인을 사용

> 배열의 색인: 배열의 순서
> 기억장소 이용률 = 정보들의 총 수/ 비트들의 총 수

> 2차원 배열
> 	행중심 int(x)(y) x가 기준
> 	열중심 int(x)(y) y가 기준
> 물리적 주소는 마치 하나의 배열인 것 처럼 저장됨
> 즉 3 * 4 형태의 배열이면 12개짜리 배열인 것처럼 저장됨

> 3차원 배열
> 	면, 행, 열
> int(x)(y)(z)

## 학습 정리

> 리스트, 스택, 큐와 같은 순차 구조와 트리, 그래프와 같은 비순차구조는 프로그램으로 구현하는 방식에 따라 순차 자료구조와 연결 자료구조로 나눌 수 있다.


---

# 구조체(structure type)

> 하나 이상의 변수를 그룹지어서 새로운 자료형(복잡한 데이터 표현) 정의
> 사용자 정의 자료형
> 배열과 달리 구조체는 다양한 타입의 변수 집합을 하나의 타입으로 표현

```c
struct name {
	int n; // member or memeber variable
	char c;
}

struct name1 {
	int n;
} show;
```

> 구조체 선언, 선언 및 초기화
> 구조체의 멤버 접근은 이름(.)

```c
typedef struct { 
	int n;
} STD;

int main() {
	STD s1 = {10};
	STD s2 = {.n = 20};
	return 0;
}

```

> 어떠한 자료형 이름에 대해 새 이름을 부여하는 목적으로 사용


# 범용 리스트(generalized list)

> 유한개의 순서가 있는 노드 또는 리스트들로 구성된 집합
> A = (a,b,(c,d)) => A.length = 3

> 다항식의 표현, 희소 행렬 등

> 공백리스트(empty list, 0, nil) => S = ()
> 부분리스트(sublist) => 임의의 주어진 리스트가 다른 리스트의 노드 또는 리스트
> 헤드: 첫번째 원소
> 테일: 첫번째 원소를 제외한 나머지 원소
> 순환리스트: 임의의 주어진 리스트의 항목이 동일한 부분 리스트인 경우
> 	C = (a,C)

> 다항식(polynominal)
> aX^e 형식의 항들의 합으로 구성된 식
> p(x) = a(n)X^n + a(n-1)X^(n-1)....
> 다항식의 ADT
> 데이터: 순서쌍의 집합으로 표현된 다항식
> 연산자 및 연산내용: zeroP, isPzero, coef, maxExp, addTerm, delTerm, mult, addpoly, multpoly ...

# 범용 리스트의 응용 (다항식 / 희소행렬)

### 다항식의 리스트 표현
> 어떻게 저장할 것인가?
> (지수, 계수)의 쌍에 대한 선형 리스트로 표현
> A(x) = 4X^3 + 3X^2 + 2 => (3,4,2,3,0,2)

> 1차원 배열을 이용한 표현
> 0 ~ n => n - i 차수의 계수 저장
> A(x) = 4X^3 + 3X^2 + 2 => (4,3,0,2)
> B(x) = 3X^1000 + X + 4 => (3, 0, 0 ..... 1, 4) -> 메모리 낭비 심함

> 2차원 배열을 이용
> 다항식의 계수가 0이 아닌 항만 표현
> (지수, 계수) => {{1000, 3}, {1,1}, {0,4}}
> 차원(degree)이 계수가 0인 항보다 많은 경우 메모리 손해가 더 큼

> 다항식 A와 다항식 B를 더하라
> 결과: 다항식 C ( A + B )
> 시간복잡도 = while 문의 반복 횟수 = O(n + m) n,m은 다항식 A,B의 항의 갯수


### 희소행렬(sparse matrix) <=> 밀집행렬(dense matrix)

> 행렬 원소의 값 중에서 '0'의 값을 비교적 많이 가지는 행렬
> 0의 비율에 대한 정확한 기준은 없음 (2/3 이상..)
> 2차원 배열로 나타낼 때, 공간 낭비가 심함 ( 0 값을 기억장소에 저장하는 것은 기억 공간 낭비가 심함 )

> 희소행렬의 ADT
> 데이터: 3원소쌍의 집합(x,y,z)
> Row={}, Column={}
> 연산: Smcreate, transpose, Smadd, Smmult ...

> 전치행렬 연산: 행렬 A = m * n => 행렬 A`= n * m
> 	행렬을 열 중심으로 전치하면 동시에 sort가 가능함

> 희소행렬의 표현(0이 아닌 원소만 저장하는 방법이 필요)
> 배열 및 연결리스트를 이용

> 2차원: 0이 아닌 원소의 개수(행) - 값(열)
> n차원: t * (n+1)

> 희소행렬 (mn)에 대한 시간 복잡도 = O(mt) -> 0이 없으므로 m개에 대해서만 작업 수행
> 	일반행렬에(mn)에 대한 시간 복잡도 = O(mn)

