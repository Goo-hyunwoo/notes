# 운영체제의 발전 과정

> 0(1940): OS없음, 기계어 사용
> 1(1950): IBM701(OS 효시), 작업 간의 원활한 변환, 버퍼링, 스풀링, 일괄 처리 시스템
> 2(1960 초): 고급 언어로 OS 작성, 장치 독립성, 다중 프로그래밍, 다중처리, 시분할 시스템
> 3(1960 중 ~ 1970 중): IBM360, UNIX, 범용 시스템, 다중 모드 시스템
> 4(1970 중 ~): 네트워크 시스템, 가상 머신, 분산 데이터 처리, 개인 컴퓨터

> 트랜잭션: 작업의 단위

> 1990년대 GUI(Graphical User Interface)

# 운영체제 기능

> OS는 사용자에게 인터페이스를 제공하여 편의성을 제공하고, 자원을 관리하여 효율성 증대
> 프로그램을 실행하는데 필요한 환경, 자원을 제공하고 관리하기 위한 크고 복잡한 시스템
> 논리적으로 작은 모듈로 구성되며 각 부분은 명확하게 정의
> 커널: OS의 핵심 모듈, 커널 역시 모듈이 집합
> >> 도커가 알파인 같은 최소 단위의 OS로 구동될 수 있는 이유 (필요 없는 모듈 제거)

#### 자원 관리 기능
> 메모리, 프로세스, 장치, 파일 등의 시스템 구성 요소를 자원이라 하며, OS는 이런 자원을 관리하는 역할

> 메모리 관리(RAM / HDD)
> 프로세서는 명령어를 수행하기 위해 메인 메모리에 명령어를 기억하며, 절대주소로 매핑하여 저장
> 	할당, 회수, 주소설정, 메모리 용량 관리
> 메인 메모리의 저장공간이  제한적이므로 보조기억 장치에 사용하고, 저장 기법에 따라 저장
> 	용량 관리, 할당, 디스크 스케줄링

> 프로세스 관리
> 프로세스 하나는 자신의 업무를 수행하기 위해 프로세서 점유, 메모리, 파일, 입출력장치 등 다양한 자원 사용
> 자원은 프로세스의 라이프사이클 중 할당
> 하나의 프로세스는 한 시스템에서 작업 단위이며, 시스템은 프로세스의 집합으로 구성
> 모든 프로세스는 프로세서를 분할하여 사용함으로써 병행하여 수행 가능
> 	프로세스와 스레드 스케줄링, 생성, 제거, 중지, 재수행, 동기화와 통신기법 제공, 교착상태 방지 기법 제공

> 장치 관리(입출력 관리)
> OS는 특정 하드웨어 장치를 포괄적 기계로 인식하게 하여 장치의 특성 숨김
> 	임시 저장(buffer-aching) 시스템, 장치 드라이버 인터페이스

> 파일 관리(데이터 관리)
> 물리적으로 다양한 형태로 정보 저장, 효율적인 사용을 위해 단일화된 정보 저장 형태 제공
> 파일의 추상적인 개념을 운영하고 쉽게 사용하기 위해 디렉토리로 구성, 다수 사용자에 의한 파일 접근 제어
> 	파일과 디렉터리의 생성과 제거, 보조기억 장치에 있는 파일 매핑, 안전한 저장 매체에 파일 저장

> 기타 기능
> 시스템 보호: 프로세스를 다른 사용자의 프로그램으로부터 보호
> 네트워킹: 완전 접속과 부분 접속으로 연결
> 명령어 해석기와 시스템 관리

# 운영체제 서비스

#### 부트스트래핑 서비스
> OS가 적재되는 과정을 부트스트래핑(Bootstraping) 또는 부팅(Booting)이라고 함
> 	OS가 보조기억장치에서 주기억장치로 적재되는 일련의 과정을 부트스트래핑이라고 함
> 부트스트랩 로더(Bootstrap Loader)는 디스크 트랙 0, 나머지는 디스크의 다른 부분에 적재
> 	부트스트랩 로더는 ROM에 저장되어 있고, 가장 먼저 로드됨
> 부트스트랩 로더는 운영체제를 적재하는 목적으로 존재하며, 운영체제를 적재하면 시스템 초기화 됨
> 초기화의 목적은 운영체제 정리, 사용자와의 대화를 통한 시간 등의 설정, 명령 해석기의 적재와 준비 등

> Q) 빠른 부팅 시스템은 초기화의 과정을 줄이고, 필요한 부분부터 먼저 로딩하고 실행하는 것인가?

#### 사용자 서비스
> 프로그래밍 작업을 쉽게 수행할 수 있도록 제공되는 서비스
> 사용자 인터페이스 (Command Line Interface, Graphical User Interface)
> 프로그램을 메모리에 적재하여 실행하거나 정지 시키는 역할 수행
> 입출력 동작 제공
> 파일 시스템을 조작(Directory, File) 
> 통신: 동일한 컴퓨터 또는 네트워크에 의해 묶인 컴퓨터 시스템에서 수행되는 프로세스 간에 발생
> 오류 탐지: 탐지, 일관성 있는 계산을 보장하기 위한 적절한 조치 수행

#### 시스템 서비스
> 자원 할당: 다수의 사용자, 다수의 작업이 동시에 실행 시, OS는 자원을 작업에 할당, 관리함
> 계정: 각 사용자의 시스템 이용 정보 확인 가능
> 보호: 호출을 위해 전달된 모든 매개변수의 타당성을 검사, 시스템 자원에 모든 접근을 제어하도록 보장
> 다중 사용자 컴퓨터 시스템에서 저장된 정보의 소유자는 정보 사용 제한

#### 부트스트래핑 서비스
> 프로세스 제어
> 	종료, 취소, 적재(로드 load), 수행
> 파일 조작
> 장치 조작
> 정보 관리(시간, 일자, 데이터 설정 및 획득 등)
> 통신


---

# 프로세스 개요

> CPU(프로세서)를 관리하기 위해 프로세스 관리
> 1960년대 멀틱스 시스템 설계자가 처음 사용
> 작업(Task)와 유사
> 실행 중인 프로그램
> 	CPU가 사용할 수 있도록 메인 메모리에 적재되어 OS의 제어를 받는 상태
> 	해당 프로세스는 메모리 영역(주소 공간)이 존재
> 	프로세서 할당(점유) 시간과 메모리, 파일, 입출력장치 등의 자원 필요, 프로세스의 생성과 실행 시 할당
> 		프로세스 생성: 프로그램을 프로세스로 바꾸는 순간
> 		프로세스 실행: 프로세스가 CPU를 점유 중인 상태
> 	현재의 활동 상태를 나타내는 프로그램 카운터와 프로세서의 현재 활동(레지스터 내용) 포함
> 	
> > 프로그램이란 보조기억장치에 저장되어 있는 상태

#### 프로세스 개념
> 프로그램과 달리 프로세스는 메모리에 주소 공간을 갖는 능동적인 개체
> 메모리에 존재하는 프로세스 주소 공간 구조
> 	실행 스택(stack) - 실행 힙(heap) - 데이터(정적 변수) - 텍스트(code)
> 	스택: 호출된 프로시저(함수)의 복귀 주소와 지역 변수 등의 일시적인 데이터를 저장하는 영역
> 	힙: 텍스트 영역과는 별도로 유지되는 자유 영역
> 	데이터: 프로세스 실행 중 동적으로 할당 받는 영역, 전역 또는 정적 변수 저장
> 	텍스트: 프로세서가 실행하는 코드 저장

>> JVM은?

#### 재진입 프로그램(재진입 코드)
> 메모리 내에 동일한 사본을 여러 사용자가 공유할 수 있도록 작성된 프로그램 또는 루틴
> 	실행 스택과 공통적 데이터를 보관하는 데이터 영역을 가짐
> 	텍스트 영역은 같으나 별도의 스택에 서로 다른 데이터를 가지므로 별개의 프로세스로 인식됨
> 	데이터베이스, 문서 편집기 등(Notepad, Excel ... )

#### 사용자 관점, 시스템 관점
> 세그먼트(코드, 데이터, 스택 등)의 가상 주소 공간을 갖는 상태를 의미
> 실행중인 프로그램을 의미

> 처리 상태에 있는 데이터 구조로 표현 가능
> 	스케줄러(디스패칭)에 의해 프로세서 할당
> 	파일에 관련된 자원에 대한 참조(장치 관리, 메모리 관리)
> 	프로세스 지원과 협력에 관한 정보(교착상태, 보호, 동기화) 교환
> 	프로세스 관련 연산은 생성, 종료, 보류, 자원 할당, 해제 등


#### 정리
> 보조기억장치에 있는 프로그램이 주기억장치로 적재된 것을 프로세스라고 함
> OS에 의해 입출력장치, 프로세서 점유, 메모리의 주소공간을 부여받는 프로그램의 인스턴스

# 프로세스 관리

#### 프로세스 종류

> 운영체제 프로세스
> 	커널 프로세스 또는 시스템 프로세스
> 	프로세스 실행 순서 제어
> 	사용하고 있는 프로세스가 사용자나 운영체제 영역을 침범하지 못하게 감시하는 역할 수행
> 	사용자 프로세스 생성, 입출력 프로세스 등 시스템 운영에 필요한 작업 수행
> 사용자 프로세스: 사용자 코드 수행

> 병행 프로세스: 프로세스 여러 개가 동시에 실행되며 독립 프로세스와 협동 프로세스로 구분
> 독립 프로세스: ㅍ로세스 여러 개가 병행하여 수행 시 주어진 초기값에 따라 항상 같은 결과를 보여줌
> 서로 독립적으로 실행되어 다른 프로세스에 영향을 받지 않고, 데이터를 공유하지 않음
> 협동프로세스: 다른 프로세스에 영향을 주거나 영향을 받음
> 제한된 자원을 공유하는 프로세스들이 통제되어 상호작용학나 협동하는 경우, 통신 방안 필요

> 실행 / 비실행 프로세스
> 프로세스는 실행되며 상태가 변하므로 운영체제는 프로세스 제어에 필요한 프로세스 상태를 점검해야 함
> 	프로세스 생성 시 비실행 상태로 초기화되어 실행을 기다림
> 	실행 중인 프로세스 종료 또는 인터럽트 발생 시, 비실행 프로세스 중 선택된 프로세스가 실행상태로 변하고(디스패치), 인터럽트 된 프로세스는 비실행 상태로 변경
> 실행 상태 프로세스
> 	실행: 명령어가 실행되는 상태, 즉 프로세스가 프로세서를 점유한 상태
> 	대기 또는 보류: 프로세서가 이벤트(입출력 종료와 같은 외부 신호)가 일어나길 기다리는 상태
> 	준비: 프로세스가 프로세서를 할당 받기 위해 기다리는 상태
> > 디스패치 -> 디스패처 서블렛
> > 만약에 WAS가 이벤트를 수신했을 때, OS에 의해 실행 상태가 되지 않는다면?
> 
> 모든 프로세스는 종료되어 시스템을 떠날 떄까지, 준비, 실행, 대기(보류) 상태로 변화되며 실행되는 과정 반복
> OS는 Process Scheduler를 이용하여 프로세스 상태 변화를 관리
> 작업 스케줄러
> 스플러가 디스크에 저장한 작업들 중 실행할 작업을 선정, 준비 리스트에 삽입
> 이를 통해 다중 프로그래밍 정도를 결정하는 핵심적인 역할 수행
> 선정한 작업에 대한 프로세스의 생성에서 종료까지의 과정 수행을 위해 프로세스 상태 변화를 일으킴

#### 프로세스 상태 변화
> 실행 프로세스가 자발적으로 프로세서 반환 전 할당된 시간이 경과하면 준비 상태로 변경
> 	시간 경과로 인한 프로세서 점유 해제: 준비, 인터럽트 발생 시: 대기(보류)
> 실행 프로세스가 시행하다 입출력 명령이 발생 시 대기(보류) 상태로 변경
> 대기 프로세스는 보류 이유가 제거되면 준비 상태로 변경
> 준비 프로세스는 디스패처(Dispatcher)가 프로세서를 할당하면 다시 실행상태로 변경
> > 비동기 프로그래밍을 한다는 것은 대기 프로세스로 만드는 건가?
> 준비 -> 실행
> 디스패치(Dispatch): 준비 리스트 맨 앞에 있던 프로세스가 프로세서를 배당받는 것
> 시간 할당: 실행 프로세스가 프로세서를 일정 시간만 사용할 수 있도록 시간 제한, 프로세서 독점 방지
> 실행 -> 준비
> 프로세스가 프로세서를 점유한 상태를 '프로세스가 실행 상태에 있다.'
> 운영체제는 프로세스의 독점을 방지하기 위해 인터럽트 클록을 둠
> timeout(프로세스명): 실행 -> 준비
> 실행 -> 대기(보류)
> 실행 프로세스가 지정 시간 전에 입출력 연산 등이 필요하거나 새로운 요청 등의 문제 발생 시 스스로 프로세서를 양도하고 대기 상태로 변경
> 대기(보류) -> 준비
> 깨움(Wake up): 프로세스의 마지막 상태 변화로 입출력 작업이 끝났을 때 발생

> 실행 -> 대기(보류)만 프로세스가 스스로 변경하는 상태

#### 프로세스 제어 블록(PCB: Process Control Block)
> 프로세스는 OS내에서 프로세스 제어 블록이라 표현하며, 작업 제어 블록이라고 함
> 	프로세스를 관리하기 위해 유지되는 데이터 블록 또는 레코드의 데이터 구조
> 	프로세스 식별자, 프로세스 상태, 프로그램 카운터 등의 정보로 구성
> 	프로세스 생성 시 만들어지고, 메인 메모리에 유지, OS에서 한 프로세스의 존재를 정의
> 	프로세스 제어 블록의 정보는 OS의 모든 모듈이 읽고 수정 가능

#### 프로세스 교환
> 인터럽트, 트랩, 시스템 호출로 나타남
> 제어를 넘겨줄 떄, 프로세스에 대한 정보를 저장

> 문맥 교환
> | P1이 프로세서 반납 -> OS  -> PCB1에 P1문맥 저장(현재의 프로세스 변경 지점 저장) 
> -> OS -> PCB2에 P2의 문맥 복구 | 
> -> P2 프로세스 실행 
> -> | P2 프로세서 반납 -> OS  -> PCB2에 P2 문맥 저장 
> -> OS -> PCB1에 P1 문맥 복구 | 
> -> P1 프로세스 실행
>> 프로세스의 실행 시간 사이의 지점은 CPU의 유휴 시간
>
>