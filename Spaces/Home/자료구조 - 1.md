# 자료구조의 개요

> 자료: 현실 세계에 대한 관찰을 통해 얻어진 값(사실)으로 가공되지 않은 그 자체
> 정성데이터 / 정량데이터

> 정보: 정보처리시스템을 통해 어떤 조직에 의미있게 적절히 사용될 자료를 처리하여 얻어진 값
> DIKW 모델 : 데이터 -> 정보 -> 지식 -> 지혜 (Data, Information, Knowledge, Wisdom)

> 자료구조: 자료의 효율적인 접근 및 수정이 가능하도록 자료를 조직, 관리 저장하는 일련의 작업
> 데이터 값의 모임 또는 데이터 간의 관계 그리고 데이터에 적용할 수 있는 함수나 명령을 의미

> 필요한 이유: 최적의 프로그램 작성 ( 기억공간의 절약, 프로그램 수행 시간의 최소화 )

> 자료구조의 선택: 자료구조와 어떤 알고리즘 설계하냐에 따라 프로그램의 성능이 달라짐
> 순차적인 탐색이 주로 수행되는 문제 / 삭제 연산이 주로 수행되는 문제에 적합한 자료구조는 서로 다름

> 적합한 데이터 구조를 선택하기 위한 과정
> 문제의 해답을 만족해야 하는 데이터의 제약 조건을 파악
> 문제를 해결하는데 필요한 기본 연산 결정
> 기본 연산들이 요구하는 특별한 데이터 형태가 있는지 파악
> 위의 요구사항들을 가장 잘 만족시키는 자료구조 선택

### 프로그램

> 특정 작업을 수행하는 일련의 명령어들의 모음
> 즉 데이터를 표현(자료구조)하고, 표현된 데이터를 처리(알고리즘)하는 명령어 집합체

### 컴퓨터(정보처리시스템)

> 자료를 수집, 분석, 저장하고 컴퓨터를 이용하여 유용한 형태의 정보로 가공하고 공유하는 일을 체계적이고 효율적으로 가능하도록 해주는 시스템

### 자료구조의 종류

> 단순(Primitive) 비단순(non-primitive)
> 단순구조: 컴퓨터가 기본적으로 제공하는 자료형
> 비단순구조: 
>   선형구조(데이터들이 일렬로 저장되어 있는 형태)
>   비선형구조(데이터들이 상하관계의 계층 구조형태)
>   파일구조

### 자료표현의 단위

> 자료의 물리적 단위와 논리적 단위
> 비트(bit): 정보 표현의 최소 단위로서 2가지 상태를 표시하는 2진수 1/0
> 니블(nibble=4bit)
> 바이트(byte=8bit)
> 워드(word): CPU가 한 번에 처리할 수 있는 명령 단위(half/full/double) 

> 필드(field): 자료구성 단위, 자료처리의 최소단위, 파일구성의 최소 단위
> 레코드(record): 하나 이상의 관련된 필드들의 모임, 프로그램 처리의 기본 단위
> 블록(block): 프로그램(저장장치)에 입출력될 때의 기본 단위(물리적 레코드)
> 파일(file): 응용프로그램 구성의 기본 단위(레코드들의 집합)
> 데이터베이스(database): 서로 관련된 파일들의 집합

### 자료 표현의 개수

> n비트 -> 2^n

### 자료 표현의 종류

> 컴퓨터에서 자료의 내부/외부적 표현(종류)

> 수치자료: 10진수 (zone, pack), 2진수 - 정수(부호화 절대값, 1의 보수, 2의 보수) , 실수(고정소수점, 부동소수점)
> 문자자료(BCD, EBCDIC, ASCII)
> 논리자료
> 포인터자료
> 문자열자료

### 진법

[[컴퓨터구조 - 1]] 진법 부분 참조
> 컴퓨터는 기본적으로 2진법으로 자료를 저장하므로, 사용자가 보기 쉽도록 변환 필요

### 수치자료의 표현

> 10진수의 표현
> 존(ZONE)영역 : 415 -> 1111 0100 1111 0001 1100 0101 -415 1111 0100 1111 0001 1101 0101
> 3번째 존에서 부호가 결정됨
> 팩(PACK)형식: 0100 0001 1010 1100 / 1101 마지막 존이 부호

### 보수(complement)

> 컴퓨터가 기본적으로 수행하는 덧셈 연산을 이용하여 뺄셈을 수행하기 위해 사용 (A-B = A+(-B))
> 5 -> 0101 -> 1010(1의 보수) -> 1011(2의 보수)

#### 보수의 연산

> -1의 보수 뺄셈: 빼는 수의 1의 보수를 구한 다음 더함
> 덧셈 결과가 최상위 비트에서 자리올림이 생기면 최상위 비트를 제외하고 최하위 비트에 1을 더함
> 자리올림이 생기지 않으면 연산 결과에 1의 보수를 구한 후 - 부호를 붙임

> -2의 보수 뺄셈: 빼는 수의 2의 보수를 구한 다음 더함
> 덧셈 결과가 최상위 비트에서 자리올림이 생기면 자리올림을 제외한 나머지 부분이 연산 결과
> 자리올림이 생기지 않으면 연산 결과의 2의 보수를 구한 후 - 부호를 붙임

### 수치자료의 표현

> 2진수의 정수 표현(8비트로 부호화 절대치 형식)
> 최상위 비트에 부호를 표시 : 양수(0), 음수(1)
> 나머지 7비트는 2진수의 절대값을 표현
> n비트의 표현 수: -2^(n-1) + 1 ~ 2^(n-1) -1

> 2진수의 정수 표현(8비트로 1의 보수 형식)
> 음수의 표현에서 부호 비트를 사용하는 대신 1의 보수를 사용하는 방법
> n비트를 1로 한 2진수에서 변환하고자 하는 2진수를 뺌

> 2진수의 정수 표현(8비트로 2의 보수 형식)
> 음수의 표현에서 부호 비트를 사용하는 대신 2의 보수를 사용하는 방법
> n비트의 표현 수: -2^(n-1) ~ 2^(n-1) -1 
> ** +0 / -0의 구분이 없기 때문에 한 자리 더 사용 가능

> 2진수의 실수 표현(고정소수점 형식)
> 소수점이 항상 최상위 비트의 왼쪽 밖에 고정 00011 -> 0.00011

> 2진수의 실수 표현(부동소수점 형식)
> 고정소수점 표현 방식보다 표현 가능한 값의 범위가 큼
> 적은 비트로 매우 크거나 작은 값을 표현하여 효율적임, 오차가 발생, 연산 속도 느림
> 부동소수점에 대한 IEEE 754 표준
> - Single Precision 부호(1) 지수(8) 가수(23) - 32비트
> - Double Precision 부호(1) 지수(11) 가수(52) - 64비트
> 정형화: 234 -> (정규화) -> 0.234 * 10^3

#### 부동소수점의 표현 예시
> 10진수 -12.31 = -1100.010011........
> 정규화 (1.xxxx) 형태로 변경
> -> -1.100010011..... * 2^3  :: 지수부 3, 가수부 100010011....

> 지수부의 바이어스 표현법(32비트 기준)
> 2^8 (0~255) 가지의 표현 : -127(0000 0000) ~ 128(1111 1111)
> 따라서 0~126은 음수, 127(0111 1111) = 0, 128~255은 양수를 표현 128(1000 0000) = 1

> (0000 0000)은 underflow 처리용(음수 값이 지수부의 음수 표현을 초과할 경우)
> (1111 1111)은 overflow 처리용(지수부가 최대 영역보다 커질 경우)
> 바이어스 값(가운데 값 127, 0111 1111)

> 즉 지수부 2^3 = 8
> 정형화 결과 1 1000 0100 100010011.....

### 문자자료의 표현

>문자 코드란 컴퓨터에서 2진자료와 매핑한 문자

#### BCD(Binary-Coded Decimal)
> 6비트를 이용하여 표현함
> 상위 2비트: 존비트, 하위 4비트: 숫자 비트(2진수)

#### EBCDIC(Extended Binary Coded Decimal Interchange Code)
> 8비트를 이용하여 표현
> 상위 4비트: 존비트, 하위 4비트: 숫자 비트(2진수) 
> 대소문자 표현 가능

#### ASCII(American Standard Code for Information Interchange)
> 7비트를 이용하여 표현
> 상위 3비트: 존비트, 하위4비트: 숫자비트(2진수)
> 남는 1비트를 데이터변조(손상)를 확인하는 패리티 비트로 활용 가능

#### 유니코드(Unicode)
> 국제 표준코드로서 16비트의 코드 값을 4자리의 16진수로 표시하여 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 표준 코드
> (0041)<16> -> A(0000 0000 0100 0001)<2>

### 논리자료의 표현

> 논리값(true/false): 1/0중 하나를 표시한 값

### 포인터 자료의 표현

> 메모리 주소를 표현(저장)하기 위한 자료
> 포인터 자료를 사용하면 복잡한 자료구조 연산을 메모리의 주소연산만으로 연산 가능

### 문자열 자료의 표현

> 문자 그룹을 하나의 자료로 취급하여 메모리에 연속적으로 저장하는 자료
> 문자열 하나는 부분 문자열(substring)을 여러 개 포함 가능

> 부분 문자열을 포함하는 문자열 자료를 메모리에 저장하는 방법
> 	1. 부분 문자열 사이에 구분자를 사용하여 저장
> 	2. 가장 긴 문자열의 길이에 맞춰 고정 길이로 저장
> 	3. 부분 문자열을 연속하여 저장하고 각 부분 문자열에 대한 포인터를 사용

> 문자(Char)와 문자열(String) 
> C언어에서는 포인터에 문자열의 주소를 저장 char *s1  = "I Love You"; -> I Love You(null)


## 학습정리

- 자료구조는 자료의 효율적인 접근 및 수정을 가능하도록 자료의 조직, 관리, 저장하는 일련의 작업
- 프로그램은 데이터를 표현(자료구조)하고, 표현된 데이터를 처리(알고리즘)하는 것으로 추상적인 형태의 알고리즘을 컴퓨터가 수행할 수 있도록 구체화한 결과물
- 보수란 컴퓨터가 기본적으로 수행하는 덧셈 연산을 이용하여 뺄셈을 수행하기 위해 사용
- 디지털 시스템에서 숫자,문자,그림,소리... 등 모든 형식의 자료는 물리적 단위(2진수)로 표현하여 저장처리
- 코드는 문자에 대한 2진 코드를 정의해 놓은 문자코드로서 컴퓨터 내부에서는 문자 자료도 1과 0의 2진수 조합으로 표현
- 부분 문자열을 구분하여 저장하는 방법에는 부분 문자열 사이에 구분자를 사용하거나, 가장 긴 문자열의 길이에 맞춰 고정 길이로 저장하는 방법, 그리고 부분 문자열을 연속하여 저장하고 각 부분 문자열에 대한 포인터를 사용하는 방법




---

# 추상화와 추상 자료형

## 추상화

> 크고 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것
> 불필요한 부분(차이점)을 생략하고 객체의 속성 중 가장 중요한 것(유사성)에 중점을 두어 개략화(모델화)

> 자료 추상화: 계산될 자료의 특성을 추상화하는 것
> 프로시져(제어 혹은 알고리즘) 추상화: 실행 순서를 제어하는 특성을 추상화하는 것

### 구체화와 비교

> 추상화: 무엇(what)인가? 를 논리적으로 정의 -> 알고리즘 정의
> 구체화: 어떻게(how)할 것인가? 를 실제적으로 표현 -> 프로그램 구현

### 추상화의 목적

> 추상화를 통해 코드의 재사용성, 가독성을 높이고, 생산성의 증가, 에러 감소, 유지 보수 용이
> 소프트웨어를 명세부와 구현부로 분리하는 것은 정보 은닉(캡슐화)를 지원
> 	객체들의 구현은 외부의 요구에 영향을 적게 받음
> 	보안성 - 구현의 세부 사항을 프로그램의 다른 부분이 변경할 수 없음

## 자료 추상화

> 데이터의 객체의 명세와 구현을 분리하는 것으로 추상화를 통해 코드의 복잡성을 줄일 수 있음
> 자료형을 기술하기 위한 도구로 객체지향기법의 기본 개념
> 객체의 정의 시 자료형과 기능적인 연산 측면으로 분리 정의하여 데이터에 대한 조작을 효과적으로 수행할 수 있는 수단을 제공
> 기본적 추상화: 컴퓨터 내부 자료 표현 추상화(변수 선언)
> 구조적 추상화: 관련된 자료 값의 집합을 추상화하는 것(인터페이스 선언)
> 단위 추상화: 프로그램 전체 정보에 대한 추상화로서 자료의 생성, 사용에 대한 정보를 모아두는 것(클래스 선언)

## 프로시저 추상화

> 제어 또는 알고리즘 추상화로 실행 순서를 제어하는 특성을 추상화한 것
> 기본적 추상화: 기계 명령어들을 모아 추상 구문으로 바꾸는 것
> 구조적 추상화: 검사 값에 따른 명령어 그룹을 실행하는 것
> 단위 추상화: 프로시저(특정 작업을 실행)의 집합을 추상화하는 것(프로그램들을 모아 하나의 단위 프로그램으로 만듬)

## 자료와 프로시저 추상화

> 자료: 컴퓨터 내부에 표현하고자 하는 자료구조, 프로그램의 처리 대상
> 연산: 자료에 대해 수행할 연산자(함수의 명칭)의 집합, 어떤 일을 처리하는 과정

## 추상 자료형(ADT: abstract data type)

> 자료 추상화를 통해 정의되는 자료형(내부속성 + 연산)으로 자료 및 연산을 모두 하나의 단위로 묶어 자료형에 속하는 값들의 집합을 고려한 후 적용 가능한 연산들을 정의해가면서 추상화시켜 구현하는 것

> 데이터와 연산의 본질에 대한 명세만 정의
> 캡슐화(encapsulation) 또는 정보은닉(information hiding)을 도모
> 구체적인 구현은 생각하지 않고, 표면적인 기능만을 생각, 사용자에게 what을 제공하고 how를 위임

> 자연수의 ADT
> 데이터: i | i 는 정수에 포함, i >= 0
> 기능: ....

# 알고리즘

> 어떤 문제를 해결할 때 그 절차나 방법을 알기 쉽도록 기술하는 논리적인 절차 과정(여러 동작 / 명령문 모임)
> 컴퓨터에 의해 수행 가능해야 하고, 프로그램 작성이 가능해야 함

### 연구 분야

> 고안: 완벽한 자동화를 통한 알고리즘의 개발은 거의 불가능
> 이미 증명된 유용한 알고리즘들을 통해 보다 유용한 알고리즘을 개발하는데 그 의미가 있음

> 고안된 알고리즘의 검증
> 입력 값에 대하여 올바른 결과를 계산해 내는지를 밝히는 절차가 필요
> 프로그래밍 언어와는 독립적으로 올바르게 작동할 수 있음을 검증

> 분석: 고안된 알고리즘의 실행을 위해 필요한 실행시간과 기억장치를 결정하는 과정

> 테스트: 디버깅, 성능 분석


## 알고리즘의 개발

### 목표

> 자료에 대해 수행할 연산(삽입, 삭제 등) 결정 -> 알고리즘 작성
> 자료구조에 따라 적용할 알고리즘이 다양
> 선택한 자료구조를 기반으로 수행될 연산을 단계적으로 표현
> 처리시간과 기억장소 사용측면에서 효율적인 알고리즘 개발
> ** 알고리즘을 개발하는데 있어서 가장 먼저 선행되어야 할 것은 주어진 문제에 대한 확실한 이해

### 모든 문제에 대한 알고리즘은 존재하는가?

> 주어진 문제를 해결하기 위한 알고리즘(해답)을 찾을 수 없는 문제들도 존재함


## 알고리즘의 개발에 필요한 사항

> 입력, 출력, 명확성, 유한성, 효과성
> 
> 자료가 외부에서 제공될 수 있음
> 문제가 처리되면 반드시 하나 이상의 결과값을 산출
> 알고리즘의 각 단계는 무엇을 하기 위한 것인지 명확하게 정의
> 알고리즘의 명령어대로 수행했을 때 주어진 값이 처리된 후 종료되어야 함
> 알고리즘은 효율적일수록 가치가 높으며, 시공간적 효율성을 가져야 함

### 알고리즘 표현 방법 (ADL: algorithm description language)

> 자연어 표현 방법
> 순서도 표현 방법
> 의사코드 표현 방법 : 코드는 아니지만 코드에 가까운 표현, 언어와 무관하게 표현 가능 😀
> 프로그래밍 언어 표현 방법



## 알고리즘의 분석

### 알고리즘의 분석 이유 및 기준

> 같은 문제를 해결하는데 여러 가지 알고리즘이 존재할 수 있음
> 주어진 상황에 따라 적절한 알고리즘을 선택(최상의 알고리즘은 없음)
> 속도에 비중을 둘 것인지, 단순성에 중점을 둘 것인지를 서로 비교 분석
> 객관적인 알고리즘의 분석 방법 필요

> 컴퓨터에서의 실행 시간과 기억 공간을 기준으로 분석
> 컴퓨터의 성능, 프로그램 언어와 작성자에 의존
> 운영체제에 따라 동일한 결과를 산출하지 못하는 경우도 있음

> 점근적 복잡도(complexity)
> 알고리즘이 주어진 데이터의 크기를 기준으로 비교할 수 있는 객관적 기준을 의미
> 실행시간 소요량(계산량, 실행 빈도수, 차수) = 시간복잡도
> 기억장소 사용량 = 공간복잡도

### 시간복잡도

> 프로그램을 실행시켜 완료하는데 걸리는 시간
> 표현식: 컴파일 시간 + 실행시간 각 명령문 하나를 실행하는데 걸리는 시간
> 프로그램의 시간복잡도 분석은 실행 빈도수를 계산함
> 가장 기본적인 연산 부분만을 고려한 실행 횟수 파악

> 명령문 1, 반복문 반복횟수

> 계산량(실행빈도수) 표현 방법
> 입력 데이터 크기의 함수로 표현함
> 입력 데이터의 크기가 동일한 경우 입력 데이터의 상태에 따라 다름 (1,2,3,4,5) (1,3,2,5,4)

> 반복문 (4n), 이중반복문(4n^2) ...


### 공간복잡도

> 프로그램(알고리즘)을 실행시켜 완료하는데 필요한 총 저장공간을 의미
> Instruction Space : 컴파일된 명령어들을 저장하는 기억공간의 양
> Environmental Stack : 함수 호출 시 부분적으로 실행된 함수의 정보를 저장하는데 사용되는 기억공간의 양
> Data Space : 모든 변수와 상수를 저장하는 기억공간의 양

> 표현식: 기억공간 = 고정공간(상수) + 가변공간
> 고정공간: 프로그램과 상관없이 고정적으로 필요한 저장 공간
> 가변공간: 실행과정에서 자료 구조와 변수들이 필요로하는 변화하는 기억 공간
> 기억장소 사용량이 특정 입력에 따라 다를 경우 최악, 평균, 최상의 경우로 표현
> 예시) n!의 연산에서 반복문 사용 시, 반복변수와 기본변수 2개로 O(2) 필요
> 예시) 재귀함수 사용 시 O(n) 필요(재귀함수가 stack에 쌓이기 때문)

### 점근식 표기법(asymptotic notation)

> Big - O 표기
> f, g가 양의 정수를 갖는 함수, 두 양의 상수는 c, n0, 모든 n >= n0에 대하여
> f(n) <= cg(n)이다. -> f(n) = O(g(n))
> g(n)을 f(n)의 점근상한(asympotic upper bound)
> 주어진 알고리즘이 아무리 나빠도 비교하는 함수와 같거나 좋음

> f(n)=3n^2 + 5n - 5 -> O(n^2)
> 계수와 낮은 차수의 항을 제외
> 상수는 삭제
> 만약 상수항만 남는다면 1로 표현
> f(n) = 100 -> O(1)

> Big - Omega 표기
> 점근하한(asympotic lower bound)

> Big - Septa
> 점근 상한 및 점근 하한
> 주어진 알고리즘이 아무리 좋거나 나빠도 비교하는 함수의 범위 안에 있음

### 계산량 함수의 증가율

> O(1) - O(log n) - O(n) - O(n log n) - O(n^2) - O(n^3) - O(2^n)
> 다항함수 - 지수함수
> <- Better, Worse ->
> 입력 크기와 동작 회수의 관계 그래프
![](계산량함수증가율.jpg)


