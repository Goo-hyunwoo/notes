
# 부동소수점 [[자료구조 - 1]]

> 정규화 과정 -> 지수 / 가수부 표현
> 바이어스 128 : 지수가 128일 때 2^0: 1을 제외하고 표현 (1000000) = 0
> 바이어스 127: 무조건 앞에 1을 표현해줘야 함 (1111111) = 0

> 부동소수점을 사용하는 이유: 매우 작은 수 / 매우 큰 수를 표현하기 위함
> 표현가능 범위 밖 - 오버플로우 / 언더플로우

> 13.625를 127 바이어스로 변경
> -> 1101.101
> -> 1.101101
> -> 127 + 3 = 127 + 1 + 2
> -> 10000010 : 2^3 : 지수부
> -> 101101 : 101101

> 107.0을 127 바이어스로 변경
> -> 0000000
> -> 1101001.0 (2^6 + 2^5 + 2^3 + 1)
> -> 1.101001 * 2^6
> 기수: 127 + 1 : 10000000
> 가수: 101001
> -> 10000000.101001

#### 2진수 연산
> 19의 2의 보수
> 00010011<2>
> 11101101<2의 보수>

> -6 + 3 = -3
> -6 : 0110<2> : 1010<2의 보수>
> +3: 0011<2> 
> 1010
> 0011
> 1101<2> -> 2의 보수 -> 0011<2>

> -3 + 5 = 2
> 0011 -> 1101 + 0101 = 10010 (캐리버림) -> 0010<2>

> -2 + -4 = -6
> 0010 + 0100
> 1110 + 1100 = 11010 (캐리 버림) -> 2의보수 -> 0110 

> 4 + 5 = 9
> 0100<2>
> 0101<2>
> 1001<2> -> 2의 보수 -> 1111<2> : -7 (overflow)

> -7 -6 = -13
> 1111<2> - 2의보수 - 1001<2>
> 1110<2>
> 1001<2의보수>
> 1010<2의보수>


#### 2진 정수의 뺄셈 연산
> 2의 보수를 사용하여 덧셈을 수행
> 최상위 비트에서 자리올림이 발생하지 않는 경우
> 최상위 비트에서 자리올림이 발생하는 경우

> 오버플로우가 발생하지 않는 뺄셈 (자리올림으로 부호비트가 변하지 않는 경우)
> +2 -5 -> 0010 - 0101 -> 0010 + 1011(2의 보수) = 1101 -> 1011(부호제외 2의보수) = -3

> +7 - (-5) = 12 -> 1100<2> -> -4 (overflow)
> -6 - 4 = -10 -> 

#### 부동소수점 수의 산술 연산
> 가수와 지수의 연산을 분리해서 수행
> 부동소수점 수의 덧셈과 뺄셈

> 지수를 같게 만들과 지수와 가수를 연산
> 2.3456 * 10^3 + 2.4528 * 10^4
> -> 2.3456 + 24.528 * 10^3
> -> ...

> IEEE 127 바이어스
> 0.110010 * 2^2 + 0.111011 * 2^3
> (0.011001 + 0.111011) * 2^3
> 1.010100 * 2^3
> 0.10101 * 2^4

#### 부동소수점 수의 곱셈
> 가수끼리는 곱연산, 지수끼리는 합연산

#### 부동소수점 수의 나눗셈
> 가수부분은 나눗셈 연산 수행, 지수부분은 뺄셈

#### 부동소수점 수의 연산 과정에서 발생 가능한 문제
> 지수 오버플로우
> 지수 언더플로우

> 가수 언더플로우
> 가수 오버플로우



# 2진수의 논리 연산
![![Spaces/Home/#^Table1]]
## 컴퓨터 응용 논리 연산(1)

#### 선택적 세트(Selective-set) 연산(OR 연산)
#### 선택적 보수(Selective-complement) 연산(XOR)
#### 마스크(mask) 연산(AND 연산)

A 1001 0010
B 0000 1111

#### 삽입(insert) 연산(MASK -> 삽입 연산)
A 1011 1010
B 1111 0000(MASK)
A 1011 0000
B 0000 1100(OR)
A 1011 1100

#### 비교(compare) 연산(XOR)

#### 순환 이동(Circular Shift) - 좌 / 우
> 1010 -> 0101

#### 산술적 이동(arithmetic shift)
> 이동 과정에서 부호 비트는 유지하고, 수의 크기를 나타내는 비트들만 이동
> 산술적 좌측 / 산술적 우측


# 문자데이터의 표현

#### 영숫자코드
> 존비트(4)
#### BCD코드
> 존비트(2) 숫자, 특수문자
#### ASCII
> 존비트(3)
> A=> 65


# 논리게이트
> 0 / 1 만 사용하는 이진 정보 게이트(gate)라고 하는 논리 회로에서 처리

#### AND 게이트
#### OR 게이트
#### NOT 게이트
#### XOR 게이트 - !A&B | A&!B
#### NAND - !(A&B)
#### NOR - !(A|B)
#### XNOR - !XOR


## 범용 논리 게이트

> NAND / NOR 게이트는 디지털 시스템에서 사용되는 모든 논리게이트를 구성한다.
> 그래서 유니버셜 게이트 / 범용 게이트라고 불린다.

> 논리 회로 설계 시, 부울 대수를 이용하면 논리 회로를 정확하고 간결하게 표현
> 부울 대수는 변수들의 진리표 관계를 대수식으로 표현하기에 용이, 동일한 성능을 갖는 더 간단한 회로를 만들기위해 사용

> D, ☽ : AND, OR


# 부울대수

#### 기본 법칙
> 교환법칙 
> 결합법칙
> 분배법칙 A(B + C) = AB + AC / A + BC = (A+B)(A+C)
> 다중부정

#### 드모르간 법칙
> !(A+B) = !A*!B, !AB = !A + !B

#### 부울 대수의 표준형
> 최소항
> 
> 최대항


---

# 논리회로

#### 입력값
> 입력값 -> 처리 -> 출력
> 처리: NOT, AND, OR, XOR, NOR, NAND, XNOR

> A, B -> 2^2

#### 합의 곱 ⍾ M (product of sum)
> (A+B+C) (A+B+!C)...
#### 곱의 합 ☈ m (sum of product)
> !A!B!C! + !A!BC ...

#### 카르노 도표
> 부울대수를 간략화한 최적 도표
> 2^2 => 2*2
> 2^4 => 16
> 2^5 => 32

> 변수의 수에 따라 박스를 그리고, 1의 위치를 잡음
> 1을 탈락되는 항 없이 묶어줌
> 바뀐 값을 제외하고 써줌

> 주어진 부울식이나 진리표에 근거하여 카르노 도표 작성
> 그룹화 수행
> 	이웃들을 그룹화
> 	가능하면 큰 개수로
> 	중복 가능
> 	이웃이 없는 경우 단독 그룹화 - 간략화 불가
> 각 그룹을 간략화
> 각 간략화된 그룹끼리 OR연산

#### 무관 조건
> 출력에 관여하지 않는 입력이 존재할 수 있음
> 무관 조건은 임의로 채워질 수도 있고, 그룹화 하지 않을 수도 있다
> x로 표기한다


# 플립플롭

> 1비트의 정보를 기억할 수 있는 회로
> 전원이 있을 때만 기억이 유지

#### 래치(Latch)
> 수동적 또는 전자적 조작으로 상태를 바꾸지 않는 한 그 상태를 유지해주는 장치
> 논리 회로로 구성되었기 때문에 논리회로에 준하는 연산 속도

> NOR게이트를 이용한 R-S 래치(Reset, Set)
> SRQ!Q
> 00----
> 0101
> 1010
> 11XX

#### R-S 플립플롭
> 일정 시간 동안 동일한 값을 유지해주는 기억 소자 (R-S Latch)로 구성
> 상태 표 / 상태 도 

#### D 플립플롭
> 지연을 위해서 사용

#### J-K 플립플롭
> R-S플립플롭의 1,1때 불능인 것을 보완한 플립플롭: !Q

#### T플립플롭
> J-K 플립플롭의 집합

